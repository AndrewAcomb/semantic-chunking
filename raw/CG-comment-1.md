---
title: "CG-comment-1"
enableToc: false # do not show a table of contents on this page
---
[[P- Chris Granger]]: This is one of those things we actually feel strongly about too. Every decision the system makes is one you should be able to make yourself directly. As a concrete example, I don't think you should really deal with the physical layout of your data, but that doesn't mean you shouldn't be able to specify it yourself. The big thing here though is that specifying it shouldn't mean you need to describe every detail like you would in C. Most tools are either fully implicit or fully explicit and the few that allow you to go from implicit to explicit throw you down into a hole from a simple world where everything was decided for you to a world where you have to define everything explicitly to make progress.

[[P- Chris Granger]]: One principle that we didn't talk about is the idea that you ought to be able to work at the level of abstraction that makes the most sense for the task at hand. E.g. if I were working with a designer, I might say "let's try something more red" but if I _were_ the designer, I'd want a color wheel to explicitly set the color. We should be able to talk very high level about the parts of the system that don't really matter to us, but be explicitly about the parts that do. Those statements about the world should be able to coexist and I should always be able to not only see what Jump has come up with, but use that as a starting point to be more explicit about how I want some of it to function.

[[P- Rob Haisfield]]: Multiplicity of possible layouts on top of the same underlying data structure (or a shifting underlying structure, like  the stairs in Hogwarts) 100%

[[P- Rob Haisfield]]: Being able to do everything explicitly that happens implicitly is a fascinating principle. I agree that underlying code instructions can be highly abstracted. I've been learning Clojure off and on out of a love for DSLs and its brand of functional programming is my starting set of mental models for how code should work. I like writing all of the code and its definitions to the point where it's as though I'm writing sentences describing what the program should do. I imagine a natural language DSL for talking with Jump that can make the whole process more natural.

[[P- Rob Haisfield]]: The levels of abstraction thing is interesting. [I wrote this](https://robhaisfield.com/notes/learn-by-going-up-and-down-the-ladder-of-abstraction) before I ever saw the [Bret Victor piece](http://worrydream.com/LadderOfAbstraction/) hence the name similarity, but it was referring to a different concept. It was a practice I first started in Notion, moved over to Roam, and want to instantiate into the data structure of a thought processor and facilitate the behavior.
 
 [[P- Rob Haisfield]]: Higher and lower level abstractions of concepts are not instantiated into any thought processor I can think of, huh. Attributes sort of get at it, but crudely?